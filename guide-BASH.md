# Курс по BASH
----

## Работа с командной строкой Linux
----

__ПРОСМОТР СОДЕРЖИМОГО В КАТАЛОГЕ__

Команда ls позволяет просмотреть содержимое каталога
```
ls
```

Вывод более упорядоченного вида с датой, размером, автором и правами
```
ls -l
```

__ПЕРЕХОД НА ДРУГУЮ ДИРЕКТОРИЮ__

С помощью команды cd
```
cd <путь к директории>
```

Например:
```
cd /home/student/log
```

*Относительный путь — относительно вашей текущей директории, где вы сейчас находитесь.*

*Можно обозначать путь оносительно домашней папки текущего пользователя. Домашняя директоория обозначается ~/ .*

*Перебирать папки при наборе директории можно с помощью tab*

Подняться на уровень выше:
```
cd ..
```

Подняться на 2 уровня выше:
```
cd ../..
```

И так до бесконечности

__КАК СОЗДАТЬ ДИРЕКТОРИЮ__

Создать директорию с названием *test*:
```
mkdir test
```

Создать папку, даже если мы не в этой директории:
```
mkdir /home/test
```

__КАК СОЗДАТЬ ФАЙЛ__

Командой touch:
```
touch app.log
```

__КАК ОТРЕДАКТИРОВАТЬ ФАЙЛ__

* nano — более простая программа, рассчитана на новичков;
* vim — более сложная, но позволяет сделать кучу всего

Начнем с nano. Указываете имя команды и путь в файлу:
```
nano test_env.json
```

Для перемещения по файлу используйте кнопки со стрелками. После того, как закончите редактировать файл, нажмите:

```
Ctrl+O — чтобы сохранить
Ctrl+X — для выхода
```

Теперь с vim. Зайти в редактор (Внимание! Прочитай сначала, как выйти.): 
```
vim test_env.json
```

Для выхода:

*Сначала нажимаем двоеточие*

```
:q — закрыть редактор
:q! — закрыть редактор без сохранения (если что-то меняли, то просто «:q» не проканает)
```

Если нужно выйти, сохранив изменения, используйте команду:
```
:w — сохранить файл;
:q — закрыть редактор
```

__СКОПИРОВАТЬ  ФАЙЛ__

```
cp что_копировать куда_копировать
```

Можно сразу переименовать файл:
```
cp app.log /home/olga/app_test_2020_03_08.log
```

*Если в «куда копировать» файл с таким именем уже есть, система не будет ничего спрашивать, просто перезапишет его.*

__СКОПИРОВАТЬ ДИРЕКТОРИЮ__

```
cp -r  путь_к_папке  путь_к_новому_месту
```

__ПЕРЕМЕСТИТЬ ФАЙЛ__

```
mv что_перемещать куда_перемещать
```

*Можно использовать относительные и абсолютные пути*

__ПЕРЕМЕСТИТЬ ДИРЕКТОРИЮ__

```
mv  путь_к_папке  путь_к_новому_месту
```

__УДАЛИТЬ ФАЙЛ__

```
rm test.txt
```

Если нужно удалить все файлы в текущей директории (скажем, вычищаем старые логи перед переустановкой приложения), используйте «*»:
```
rm *  — удалит все файлы в текущей директории
```

__УДАЛИТЬ ПАПКУ__

```
rm -r test_folder
```

А теперь представьте, что вы чистите много файлов. И на каждый система переспрашивает, и надо постоянно отвечать «да, да, да...» (y – enter, y – enter, y – enter)… Чтобы удалить все без вопросов, используйте флаг -f (force):
```
rm -rf test_folder    --- просто все удалит без разговоров
```

Опция -v показывает имена удаляемых файлов:
```
rm -rfv test_folder   --- удалит папку со всем содержимым, но выведет имена удаляемых файлов
```

__ИЗМЕНИТЬ ВЛАДЕЛЬЦА ФАЙЛА__

Допустим, что я поднимаю сервис testbase. И он должен иметь доступ к директории user и файлу test.txt в другой директории. Так как никому другому эти файлики не нужны, а создала я их под рутом, то просто меняю владельца:
```
chown testbase:testbase test.txt — сменить владельца файла
chown -R testbase:testbase user     — сменить владельца папки
```

__УСТАНОВИТЬ ПРИЛОЖЕНИЕ__

В линуксе приложения ставятся как пакеты. Для каждой системы есть свой менеджер пакетов:
```
yum — red hat, centos
dpkg, apt — debian
```

Установить приложение через yum:
```
yum install mc
```

__ЗАПУСТИТЬ ПРИЛОЖЕНИЕ__

Некоторые приложения запускаются через скрипты. Например, чтобы запустить сервер приложения WildFly, нужно перейти в папку bin и запустить там standalone.sh. Файл с расширением .sh — это скрипт.
Чтобы запустить скрипт, нужно указать полный путь к нему:
```
/opt/cdi/jboss/bin/standalone.sh — запустили скрипт standalone.sh
```

Поиск идет только в каталогах, записанных в переменную PATH. Так что если скрипт используется часто, добавляйте путь туда и вызывайте просто по названию.

Если же приложение запускается как сервис, то все еще проще:
```
service test start — запустить сервис под названием «test»
service test stop — остановить сервис
```

Чтобы сервис test запускался автоматически при рестарте системы, используйте команду:
```
chkconfig test on
```

__КАК ПОНЯТЬ, ГДЕ УСТАНОВЛЕНО ПРИЛОЖЕНИЕ__

Чтобы узнать, куда приложение установилось, используйте whereis (без пробела):
```
whereis newman
```

__КАК СОЗДАТЬ АРХИВ__

Для создания архива стандартная комбинация cvzf:
```
tar -cvzf archive.tar.gz /home/test   ---упакует директорию test
```

Для распаковки:
```
tar -xvf archive.tar.gz
```

Обозначение флагов:
```
c — создать архив в linux
x — извлечь файлы из архива
v — показать подробную информацию о процессе работы (без него мы бы не увидели, какие файлики запаковались / распаковались)
f — файл для записи архива
z — сжатие
```

Если очень хочется использовать rar, то придется изгаляться. Через yum установка не прокатит. Придется выполнить цепочку команд. Сначала скачиваем, разархивируем и компилируем.
```
wget http://rarlabs.com/rar/rarlinux-x64-5.4.0.tar.gz
tar xzf rarlinux-x64-5.4.0.tar.gz
cd rar
make install
```

Устанавливаем:
```
mkdir -p /usr/local/bin
mkdir -p /usr/local/lib
cp rar unrar /usr/local/bin
cp rarfiles.lst /etc
cp default.sfx /usr/local/lib
```

Применяем:
```
unrar x test.rar
```

__КАК ПОСМОТРЕТЬ  ИСПОЛЬЗОВАННЫЕ КОМАНДЫ__

```
↑  (стрелочка «наверх») — показать последнюю команду
history — показать последние 1000 команд
```

__ПОСМОТРЕТЬ СВОБОДНОЕ МЕСТО__

Сколько места  свободно на дисках:
```
df -h
```

Сколько весит директория:
```
du -sh
du -sh *  --- с разбиением
```

__КАК УЗНАТЬ IP КОМПЬЮТЕРА__

```
hostname -I
ifconfig — выведет кучу инфы, в том числе ваш внешний IP
ip a — аналог, просто иногда Ifconfig дает очень много результата, тут поменьше будет
```

__КАК УЗНАТЬ ВЕРСИЮ OS__

```
cat /etc/*-release
uname -a        # версия ядра
```

__ЧТО ДЕЛАЕТ ЭТА КОМАНДА?__

```
man ls      # напишет информацию о данной команде
```

__КАК СОЗДАТЬ МНОГО ТЕКСТОВЫХ ПАПОК И ФАЙЛОВ__

```
mkdir -p test/dir--{000..100}
touch test/dir--{000..100}/file-{A..Z}
```

*mkdir — создать директорию*

*touch — создать файл (или изменить существующий, но если файла с таким именем нет, то команда создаст новый, пустой)*

__КАК ПРОТЕСТИРОВАТЬ IOPS__

Используем утилиту fio — https://github.com/axboe/fio/releases.

1. Скачиваем последнюю версию, распаковываем, переходим в каталог. В командах ниже нужно заменить «fio-3.19» на актуальную версию.
```
cd /tmp
wget https://github.com/axboe/fio/archive/fio-3.19.tar.gz
tar xvzf fio-3.19.tar.gz
rm fio-3.19.tar.gz
cd fio-fio-3.19
```

2. Должны стоять пакеты для сборки.
```
apt-get install -y gcc make libaio-dev | yum install -y make gcc libaio-devel
```

3. Собираем.
```
make
```

4. Тестируем.
```
./fio -readonly -name iops -rw=randread -bs=512 -runtime=20 -iodepth 32 -filename /dev/sda -ioengine libaio -direct=1
```

Какие должны быть результаты:

* Средний SSD, выпущенный 2-3 года назад — 50 тысяч IOPS.
* Свежий Samsung 960 Pro, который стоит на одной из железок у нас в офисе — 350 тысяч IOPS.

Если должно быть 50 тысяч, а диск выдает сильно меньше, то:

* он не SSD;
* есть сетевые задержки;
* неправильно примонтирован;
* с ними что-то еще плохое случилось и стоит поднять алярм.


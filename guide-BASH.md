# Курс по BASH
----

## Работа с командной строкой Linux
----

__ПРОСМОТР СОДЕРЖИМОГО В КАТАЛОГЕ__

Команда ls позволяет просмотреть содержимое каталога
```
ls
```

Вывод более упорядоченного вида с датой, размером, автором и правами
```
ls -l
```

__ПЕРЕХОД НА ДРУГУЮ ДИРЕКТОРИЮ__

С помощью команды cd
```
cd <путь к директории>
```

Например:
```
cd /home/student/log
```

*Относительный путь — относительно вашей текущей директории, где вы сейчас находитесь.*

*Можно обозначать путь оносительно домашней папки текущего пользователя. Домашняя директоория обозначается ~/ .*

*Перебирать папки при наборе директории можно с помощью tab*

Подняться на уровень выше:
```
cd ..
```

Подняться на 2 уровня выше:
```
cd ../..
```

И так до бесконечности

__КАК СОЗДАТЬ ДИРЕКТОРИЮ__

Создать директорию с названием *test*:
```
mkdir test
```

Создать папку, даже если мы не в этой директории:
```
mkdir /home/test
```

__КАК СОЗДАТЬ ФАЙЛ__

Командой touch:
```
touch app.log
```

__КАК ОТРЕДАКТИРОВАТЬ ФАЙЛ__

* nano — более простая программа, рассчитана на новичков;
* vim — более сложная, но позволяет сделать кучу всего

Начнем с nano. Указываете имя команды и путь в файлу:
```
nano test_env.json
```

Для перемещения по файлу используйте кнопки со стрелками. После того, как закончите редактировать файл, нажмите:

```
Ctrl+O — чтобы сохранить
Ctrl+X — для выхода
```

Теперь с vim. Зайти в редактор (Внимание! Прочитай сначала, как выйти.): 
```
vim test_env.json
```

Для выхода:

*Сначала нажимаем двоеточие*

```
:q — закрыть редактор
:q! — закрыть редактор без сохранения (если что-то меняли, то просто «:q» не проканает)
```

Если нужно выйти, сохранив изменения, используйте команду:
```
:w — сохранить файл;
:q — закрыть редактор
```

__СКОПИРОВАТЬ  ФАЙЛ__

```
cp что_копировать куда_копировать
```

Можно сразу переименовать файл:
```
cp app.log /home/olga/app_test_2020_03_08.log
```

*Если в «куда копировать» файл с таким именем уже есть, система не будет ничего спрашивать, просто перезапишет его.*

__СКОПИРОВАТЬ ДИРЕКТОРИЮ__

```
cp -r  путь_к_папке  путь_к_новому_месту
```

__ПЕРЕМЕСТИТЬ ФАЙЛ__

```
mv что_перемещать куда_перемещать
```

*Можно использовать относительные и абсолютные пути*

__ПЕРЕМЕСТИТЬ ДИРЕКТОРИЮ__

```
mv  путь_к_папке  путь_к_новому_месту
```

__УДАЛИТЬ ФАЙЛ__

```
rm test.txt
```

Если нужно удалить все файлы в текущей директории (скажем, вычищаем старые логи перед переустановкой приложения), используйте «*»:
```
rm *  — удалит все файлы в текущей директории
```

__УДАЛИТЬ ПАПКУ__

```
rm -r test_folder
```

А теперь представьте, что вы чистите много файлов. И на каждый система переспрашивает, и надо постоянно отвечать «да, да, да...» (y – enter, y – enter, y – enter)… Чтобы удалить все без вопросов, используйте флаг -f (force):
```
rm -rf test_folder    --- просто все удалит без разговоров
```

Опция -v показывает имена удаляемых файлов:
```
rm -rfv test_folder   --- удалит папку со всем содержимым, но выведет имена удаляемых файлов
```

__ИЗМЕНИТЬ ВЛАДЕЛЬЦА ФАЙЛА__

Допустим, что я поднимаю сервис testbase. И он должен иметь доступ к директории user и файлу test.txt в другой директории. Так как никому другому эти файлики не нужны, а создала я их под рутом, то просто меняю владельца:
```
chown testbase:testbase test.txt — сменить владельца файла
chown -R testbase:testbase user     — сменить владельца папки
```

__УСТАНОВИТЬ ПРИЛОЖЕНИЕ__

В линуксе приложения ставятся как пакеты. Для каждой системы есть свой менеджер пакетов:
```
yum — red hat, centos
dpkg, apt — debian
```

Установить приложение через yum:
```
yum install mc
```

__ЗАПУСТИТЬ ПРИЛОЖЕНИЕ__

Некоторые приложения запускаются через скрипты. Например, чтобы запустить сервер приложения WildFly, нужно перейти в папку bin и запустить там standalone.sh. Файл с расширением .sh — это скрипт.
Чтобы запустить скрипт, нужно указать полный путь к нему:
```
/opt/cdi/jboss/bin/standalone.sh — запустили скрипт standalone.sh
```

Поиск идет только в каталогах, записанных в переменную PATH. Так что если скрипт используется часто, добавляйте путь туда и вызывайте просто по названию.

Если же приложение запускается как сервис, то все еще проще:
```
service test start — запустить сервис под названием «test»
service test stop — остановить сервис
```

Чтобы сервис test запускался автоматически при рестарте системы, используйте команду:
```
chkconfig test on
```

__КАК ПОНЯТЬ, ГДЕ УСТАНОВЛЕНО ПРИЛОЖЕНИЕ__

Чтобы узнать, куда приложение установилось, используйте whereis (без пробела):
```
whereis newman
```

__КАК СОЗДАТЬ АРХИВ__

Для создания архива стандартная комбинация cvzf:
```
tar -cvzf archive.tar.gz /home/test   ---упакует директорию test
```

Для распаковки:
```
tar -xvf archive.tar.gz
```

Обозначение флагов:
```
c — создать архив в linux
x — извлечь файлы из архива
v — показать подробную информацию о процессе работы (без него мы бы не увидели, какие файлики запаковались / распаковались)
f — файл для записи архива
z — сжатие
```

Если очень хочется использовать rar, то придется изгаляться. Через yum установка не прокатит. Придется выполнить цепочку команд. Сначала скачиваем, разархивируем и компилируем.
```
wget http://rarlabs.com/rar/rarlinux-x64-5.4.0.tar.gz
tar xzf rarlinux-x64-5.4.0.tar.gz
cd rar
make install
```

Устанавливаем:
```
mkdir -p /usr/local/bin
mkdir -p /usr/local/lib
cp rar unrar /usr/local/bin
cp rarfiles.lst /etc
cp default.sfx /usr/local/lib
```

Применяем:
```
unrar x test.rar
```

__КАК ПОСМОТРЕТЬ  ИСПОЛЬЗОВАННЫЕ КОМАНДЫ__

```
↑  (стрелочка «наверх») — показать последнюю команду
history — показать последние 1000 команд
```

__ПОСМОТРЕТЬ СВОБОДНОЕ МЕСТО__

Сколько места  свободно на дисках:
```
df -h
```

Сколько весит директория:
```
du -sh
du -sh *  --- с разбиением
```

__КАК УЗНАТЬ IP КОМПЬЮТЕРА__

```
hostname -I
ifconfig — выведет кучу инфы, в том числе ваш внешний IP
ip a — аналог, просто иногда Ifconfig дает очень много результата, тут поменьше будет
```

__КАК УЗНАТЬ ВЕРСИЮ OS__

```
cat /etc/*-release
uname -a        # версия ядра
```

__ЧТО ДЕЛАЕТ ЭТА КОМАНДА?__

```
man ls      # напишет информацию о данной команде
```

__КАК СОЗДАТЬ МНОГО ТЕКСТОВЫХ ПАПОК И ФАЙЛОВ__

```
mkdir -p test/dir--{000..100}
touch test/dir--{000..100}/file-{A..Z}
```

*mkdir — создать директорию*

*touch — создать файл (или изменить существующий, но если файла с таким именем нет, то команда создаст новый, пустой)*

__КАК ПРОТЕСТИРОВАТЬ IOPS__

Используем утилиту fio — https://github.com/axboe/fio/releases.

1. Скачиваем последнюю версию, распаковываем, переходим в каталог. В командах ниже нужно заменить «fio-3.19» на актуальную версию.
```
cd /tmp
wget https://github.com/axboe/fio/archive/fio-3.19.tar.gz
tar xvzf fio-3.19.tar.gz
rm fio-3.19.tar.gz
cd fio-fio-3.19
```

2. Должны стоять пакеты для сборки.
```
apt-get install -y gcc make libaio-dev | yum install -y make gcc libaio-devel
```

3. Собираем.
```
make
```

4. Тестируем.
```
./fio -readonly -name iops -rw=randread -bs=512 -runtime=20 -iodepth 32 -filename /dev/sda -ioengine libaio -direct=1
```

Какие должны быть результаты:

* Средний SSD, выпущенный 2-3 года назад — 50 тысяч IOPS.
* Свежий Samsung 960 Pro, который стоит на одной из железок у нас в офисе — 350 тысяч IOPS.

Если должно быть 50 тысяч, а диск выдает сильно меньше, то:

* он не SSD;
* есть сетевые задержки;
* неправильно примонтирован;
* с ними что-то еще плохое случилось и стоит поднять алярм.

## BASH-скрипты
----

Это — сценарии командной строки, написанные для оболочки bash. Существуют и другие оболочки, например — zsh, tcsh, ksh. Сценарии — это мощный способ автоматизации часто выполняемых действий.

Вводя несколько команд через точку с запятой, можно выполнять несколько команд сразу:

```
pwd ; whoami
```

Определить ограничение на  максимальное количество аргументов:
```
getconf ARG_MAX
```

__КАК УСТРОЕНЫ BASH-СКРИПТЫ__

Создаем пустой файл

В его первой строке указываем оболочку
```
#!/bin/bash
```

*В других строках этого файла символ решётки используется для обозначения комментариев, которые оболочка не обрабатывает. Однако, первая строка — это особый случай, здесь решётка, за которой следует восклицательный знак (эту последовательность называют шебанг) и путь к bash, указывают системе на то, что сценарий создан именно для bash*

Команды оболочки отделяются знаком перевода строки, комментарии выделяют знаком решётки. Вот как это выглядит:
```
#!/bin/bash
# This is a comment
pwd
whoami
```

__УСТАНОВКА РАЗРЕШЕНИЙ ДЛЯ ФАЙЛА СЦЕНАРИЯ__

Сохраняем файл. Делаем его исполняемым:
```
chmod +x ./myscript     # файл называется myscript
```

Можно выполнять его:
```
./myscript
```

__ВЫВОД СООБЩЕНИЙ__
```
echo "The current directory is:"
```

__ИСПОЛЬЗОВАНИЕ ПЕРЕМЕННЫХ__

Переменные позволяют хранить в файле сценария информацию, например — результаты работы команд для использования их другими командами.

Существуют два типа переменных, которые можно использовать в bash-скриптах:

* Переменные среды
* Пользовательские переменные

__ПЕРЕМЕННЫЕ СРЕДЫ__

Иногда в командах оболочки нужно работать с некими системными данными. Вот, например, как вывести домашнюю директорию текущего пользователя:
```
#!/bin/bash
# display user home
echo "Home for the current user is: $HOME"
```

*Обратите внимание на то, что мы можем использовать системную переменную $HOME в двойных кавычках, это не помешает системе её распознать.*

*Используйте знак \ чтобы переменные не распозновались как переменные среды*

__ПОЛЬЗОВАТЕЛЬСКИЕ ПЕРЕМЕННЫЕ__

Подобные переменные хранят значение до тех пор, пока не завершится выполнение сценария.

Как и в случае с системными переменными, к пользовательским переменным можно обращаться, используя знак доллара:
```
#!/bin/bash
# testing variables
grade=5
person="Adam"
echo "$person is a good boy, he is in grade $grade"
```

__ПОДСТАНОВКА КОМАНД__

Это возможность извлекать информацию из вывода команд и назначать её переменным.

Сделать это можно двумя способами:

* С помощью значка обратного апострофа «`»
* С помощью конструкции $()

```
mydir=`pwd`
mydir=$(pwd)
```

__МАТЕМАТИЧЕСКИЕ ОПЕРАЦИИ__

```
$((a+b))        # В скобках пишется выражение 
```

__УПРАВЛЯЮЩАЯ КОНСТРУКЦИЯ if-then__

```
if команда
then
команды
fi
```

Пример:
```
#!/bin/bash
if pwd
then
echo "It works"
fi
```

__УПРАВЛЯЮЩАЯ КОНСТРУКЦИЯ if-then-else__


Если первая команда возвратит ноль, что означает её успешное выполнение, условие окажется истинным и выполнение не пойдёт по ветке else. В противном случае, если будет возвращено что-то, отличающееся от нуля, что будет означать неудачу, или ложный результат, будут выполнены команды, расположенные после else.

```
if команда
then
команды
else
команды
fi
```

Для множества условий:
```
if команда1
then
команды
elif команда2
then
команды
fi
```

__СРАВНЕНИЕ ЧИСЕЛ__

```
n1 -eq n2Возвращает истинное значение, если n1 равно n2.
n1 -ge n2 Возвращает истинное значение, если n1больше или равно n2.
n1 -gt n2Возвращает истинное значение, если n1 больше n2.
n1 -le n2Возвращает истинное значение, если n1меньше или равно n2.
n1 -lt n2Возвращает истинное значение, если n1 меньше n2.
n1 -ne n2Возвращает истинное значение, если n1не равно n2.
```

Чтобы прописать выражение в if-then, необходимо заключить выражение в квадратные скобки.

__СРАВНЕНИЕ СТРОК__

```
str1 = str2 Проверяет строки на равенство, возвращает истину, если строки идентичны.
str1 != str2Возвращает истину, если строки не идентичны.
str1 < str2Возвращает истину, если str1меньше, чем str2.
str1 > str2 Возвращает истину, если str1больше, чем str2.
-n str1 Возвращает истину, если длина str1больше нуля.
-z str1Возвращает истину, если длина str1равна нулю.
```

Пример:
```
#!/bin/bash
user ="likegeeks"
if [$user = $USER]
then
echo "The user $user  is the current logged in user"
fi
```

*Вот одна особенность сравнения строк, о которой стоит упомянуть. А именно, операторы «>» и «<» необходимо экранировать с помощью обратной косой черты, иначе скрипт будет работать неправильно, хотя сообщений об ошибках и не появится. Скрипт интерпретирует знак «>» как команду перенаправления вывода.*

*Чтобы не было ошибки too many arguments, можно заключить аргументы в двойные ковычки*

*Команда sort, в свою очередь, использует порядок сортировки, заданный в настройках системного языка.*

__ПРОВЕРКИ ФАЙЛОВ__

```
-d fileПроверяет, существует ли файл, и является ли он директорией.
-e fileПроверяет, существует ли файл.
-f file Проверяет, существует ли файл, и является ли он файлом.
-r fileПроверяет, существует ли файл, и доступен ли он для чтения.
-s file Проверяет, существует ли файл, и не является ли он пустым.
-w fileПроверяет, существует ли файл, и доступен ли он для записи.
-x fileПроверяет, существует ли файл, и является ли он исполняемым.
file1 -nt file2 Проверяет, новее ли file1, чем file2.
file1 -ot file2Проверяет, старше ли file1, чем file2.
-O file Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.
-G fileПроверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.
```

БОЛЕЕ ПОДРОБНАЯ ИНФОРМАЦИЯ В ФАЙЛЕ: [./bash.pdf]